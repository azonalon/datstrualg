\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english, ngerman]{babel}
\usepackage{amsmath,amsthm,verbatim,amssymb,amsfonts,amscd}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{courier}
\usepackage[margin=1in]{geometry}
\lstset{
  numbers=left,
  language=C,
  basicstyle=\footnotesize\ttfamily,
  breaklines=true,
  morekeywords={function, NIL}
}
\newcommand{\abs}[1]{\left| #1 \right| }
\setlength{\parindent}{0pt} 

\author{
  Felix Schrader, 3053850 \\ 
  Jens Duffert, 2843110 \\
  Eduard Sauter, 3053470
}
\title{Datenstrukturen und Algorithmen: Haus\"ubung 3}
\begin{document}
\maketitle
\subsection*{Aufgabe 1}
\begin{enumerate}[a)]
\item
  Der folgende Algorithmus legt zunächst ein neues Array
  \texttt{permuted$\_$data} an, das mit dem Ergebnis der Permutation gefüllt
  werden soll. Dazu wird mit einer \texttt{for}-Schleife das ganze Array
  durchgegangen. Die Stelle \texttt{index} in \texttt{permuted$\_$data} wird
  dann mit \texttt{data$\lbrack$permutation$\lbrack$index$\rbrack\rbrack$}
  gefüllt, da dies der Wert ist, der nach dem permutieren an der Stelle
  \texttt{index} stehen soll.
  \begin{lstlisting}
    function permute(data, permutation) {
        permuted_data = new Array(n);
        for(index = 0, index < n, index++) {
            permuted_data[index] = data[permutation[index]];
        }
        return permuted_data;
    }
  \end{lstlisting}
  In dem Algorithmus gibt es zunächst eine Zuweisung in der Zeile:
  \begin{lstlisting}
    permuted_data = new Array(n);
  \end{lstlisting}
  Dann wird eine \texttt{for}-Schleife durchlaufen:
  \begin{lstlisting}
    for(index = 0, index < n, index++) {
        permuted_data[index] = data[permutation[index]];
    }
  \end{lstlisting}
  Der Schleifenkopf weist dann mit der Initialisierung einmal einen Wert zu,
  vergleicht dann $n$-mal, ob \texttt{index} kleiner als $n$ ist und erhöht
  \texttt{index} dann $n$-mal, was je einer Addition und einer Zuweisung
  entspricht. Dann wird der entsprechenden Stelle in \texttt{permuted$\_$data}
  ein Wert zugewiesen. Auch das passiert $n$-mal. Insgesamt erhält man also
  eine Laufzeit:
  \begin{align*}
    f (n) &= 1 + n + n + 2 \cdot n + n
    \\ &= 5 \cdot n + 1 \in \Theta (n)
  \end{align*}
  Allerdings benötigt man auch linear viel Speicher, da man ein neues Array der
  Länge $n$ erstellt.
\item 
\end{enumerate}
\subsection*{Aufgabe 2}
\begin{enumerate}[a)]
  \item  $ $
\begin{center}
\begin{lstlisting}
function insertList(L1, L2, pos) {
  L1_position = pos;
  L2_position = L2.first();

  while(L2_position != NIL) {
    L1.insert(L1_position, L2.retrieve(L2_position));
    L1_position = L1_position.next();
    L2_position = L2_position.next();
  }
}
\end{lstlisting}
\end{center}
    
  \item Laufzeit Untersuchungen:
    \begin{itemize}
      \item
        Nach Vorlesung sind die Operationen \texttt{insert}, \texttt{next}, 
        \texttt{retrieve} und \texttt{first} implementiert durch die verkettete
        Liste in $\mathcal{O}(1)$. Es sei $n=\texttt{L2.length()}$. 
        Die Schleife beginnend bei Zeile 5 wird $n$ mal durchlaufen. Jede der 
        Operationen im Schleifenkopf sowie der Vergleich zu beginn der Schleife
        sind in $\mathcal{O}(1)$. Folglich ist die Laufzeit von \texttt{insertList}
        in $\mathcal{O}(n)$.
      \item W\"urde man \texttt{L2} vor \texttt{pos} einf\"ugen wollen, so
        m\"usste man vorher die Position vor \texttt{pos} finden.
\begin{lstlisting}
function previous(L, pos) {
    last_pos = NIL;
    current_pos = L.first();
    while(current_pos != pos && current_pos != NIL) {
        last_pos = current_pos;
        current_pos = pos.next();
    }
    return last_pos
}
\end{lstlisting}
        Es sei $m=\texttt{L1.Length}$ 
        Die Worst-Case Laufzeit von \texttt{previous} ist in $\mathcal{O}(m)$,
        da in diesem Fall $m$ Elemente \"uberpr\"uft werden m\"ussen. 

\begin{lstlisting}
  function insertListPrevious(L1, L2, pos) {
      L1_position = previous(L1, pos);
      L2_position = L2.first();
  
      while(L2_position != NIL) {
          L1.insert(L1_position, L2.retrieve(L2_position));
          L1_position = L1_position.next();
          L2_position = L2_position.next();
      }
  }
\end{lstlisting}
        
        Analog zu \texttt{insertList} ergibt sich die Worst-Case Laufzeit von
        \texttt{InsertListPrevious} zu $\mathcal{O}(m + n)$.

    \end{itemize}
    


    
    
\end{enumerate}



\end{document}
